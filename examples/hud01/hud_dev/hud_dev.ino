#include <Wire.h>


#define CLK 8
#define DIN 7
#define D 1

#define PWM 6
//TM1650 - 4 digits, SCL=A5, SDL=A4
//TM1640 - 8x8 matrix CLK=D8, DIN=D7
//PWM - hud pwm=D6

byte digits_d_r[12]={0x3f, 0x30, 0x5b, 0x79, 0x74, 0x6d, 0x6f, 0x38, 0x7f, 0x7d, 0x00, 0x40};
//0x68, 0x6a, 0x6c, 0x6e
byte digits_a[4]={0x34, 0x35, 0x36, 0x37};
byte ctrl_a = 0x34;//0x48;
byte ctrl_d = 0x31;
byte d;

byte alphabet[13][16] = {
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x20, 0x10, 0x08, 0xFE, 0x00, 0x00},//N
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFE, 0x42, 0x00, 0x00, 0x00},//1
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x92, 0x8A, 0x86, 0x42, 0x00, 0x00},//2
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x92, 0x92, 0x82, 0x44, 0x00, 0x00},//3

  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFE, 0x48, 0x28, 0x18, 0x00, 0x00},//4
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0x92, 0x92, 0x92, 0xF2, 0x00, 0x00},//5
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x92, 0x92, 0x92, 0x7C, 0x00, 0x00},//6
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x90, 0x8E, 0x80, 0x80, 0x00, 0x00},//7

  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x92, 0x92, 0x92, 0x6C, 0x00, 0x00},//8
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x92, 0x92, 0x92, 0x64, 0x00, 0x00},//9
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x94, 0x98, 0x90, 0xFE, 0x00, 0x00},// R
  {0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55},// :)
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
};

byte bf[4];

int *v;
byte *rpm;
byte *gear;

//reversed code
void write_digit_r(byte a, int d){
  Wire.beginTransmission(digits_a[a]);
  Wire.write(digits_d_r[d]);
  Wire.endTransmission();

}
void wait(){
  write_digit_r(3, 11);
  write_digit_r(2, 11);
  write_digit_r(1, 11);
  write_digit_r(0, 11);
}

void start() {
  digitalWrite(CLK, HIGH); delayMicroseconds(D);
  digitalWrite(DIN, HIGH); delayMicroseconds(D);
  digitalWrite(DIN, LOW); delayMicroseconds(D);
  //digitalWrite(CLK, LOW); delayMicroseconds(D);
}
void stop() {
  digitalWrite(CLK, HIGH); delayMicroseconds(D);
  digitalWrite(DIN, LOW); delayMicroseconds(D);

  digitalWrite(DIN, HIGH); delayMicroseconds(D);
}
void write_byte(byte b) {
  static byte i;
  digitalWrite(CLK, LOW); delayMicroseconds(D);
  for (i = 0; i < 8; i++) {
    //Serial.print(b & 0x01);
    digitalWrite(CLK, LOW);
    if (b & 0x01) {
      //write HIGH
      digitalWrite(DIN, HIGH);
    } else {
      //write LOW
      digitalWrite(DIN, LOW);
    }
    delayMicroseconds(D);
    digitalWrite(CLK, HIGH); delayMicroseconds(D);

    b >>= 1;
  }
  //Serial.println("");
}
void cmd(byte c) {
  start();
  write_byte(c);
  stop();
}
void write_block(int slice, byte offset) {
  static byte c;
  start();
  //start from 0x00
  write_byte(0xc0+offset);
  //write 16 bytes profile
  for (c = 0; c < 16; c++) {
    write_byte(alphabet[slice][c]);
    //write_byte(0xff);
  }
  stop();
}
void setup() {
  // put your setup code here, to run once:
  ///4 digit init
  Wire.begin();
  //0x48>>1 = 0x24
  Wire.beginTransmission(0x24);
  //brightness 7, light on
  Wire.write(0x01);
  Wire.endTransmission();
  /// 8x8 matrix init
  pinMode(DIN, OUTPUT);
  pinMode(CLK, OUTPUT);
  digitalWrite(DIN, HIGH);
  digitalWrite(CLK, HIGH);
  cmd(0x40);
  cmd(0x8f);
  /// PWM init
  
  //initialize pointer
  v=(int*)bf;
  rpm=bf+2;
  gear=bf+3;
  pinMode(PWM, OUTPUT);
  wait();
  Serial.begin(115200);
  write_block(12, 0x00);
  //write_block(11, 0x00);
  d=2;
}
void loop() {
  // put your main code here, to run repeatedly:
  if(Serial.available()>2){
    //delay(10);
    d=0;
    Serial.readBytes(bf, 4);
    //order is big endian, reversed is little endian
    write_digit_r(3, *v>1000?*v/1000:10);
    write_digit_r(2, *v>100?(*v/100)%10:10);
    write_digit_r(1, *v>10?(*v/10)%10:10);
    write_digit_r(0, *v%10);
    write_block(*gear, *rpm>225?0x08:0x00);
    analogWrite(PWM, *rpm);
  }else{
    if(d){
      d = (d+1) | 0x02;
      //write_block(12, 0x00);
      write_block(11, 0x00+(d&0x01));
      //write_digit_r(0, d);
      delay(50);
    }
  }

  //delay(1000);
}
